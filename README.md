# Blobfish
An encryption/decryption protocol inspired from Enigma. It is a symmetric-key algorithm that reuses and generalizes some concepts of the Enigma machines, such as plugboards and rotors. This implementation is written in C++.

## Goals

Blobfish's goal is to encrypt and decrypt any kind of file. It doesn't require any specific format or file system, and both encryption and decryption should be permitted on any similar or different file systems. The contents of the file are seen as a stream of bytes, or numbers between 0 and 255. This is similar to the Enigma machine where each input and ouput was a value from a given alphabet. The process shouldn't require to load the whole file in memory, as this would limit the file size.

## Mathematical interlude

Useful notions here include basic algebra, groups, combinatorics and bijections.

Let E be a set of distinct elements, and f : E → E a function with E as both its domain and image. We can use f to encrypt and decrypt information contained in E only if it is reversible. Such a function is called a permutation of the set E. That permutation can be represented in different ways but the most intuitive may be using a table containing in one line the domain values and in the next line the corresponding image values:

| A | B | C | D |
|---|---|---|---|
| D | B | A | C |

Here f transforms A into D, B into itself, C into A and D into C. A more space-efficient representation of the same permutation is obtained with a cycle, where each element is transformed into the following one, until the last which gets transformed into the first. Elements that do not change can be omitted from the cycle: 

(ADC)

Some operations are allowed on permutations. A common one is composition, that combines multiple permutations into a single one, called the composite permutation. Composition is represented with the (round)  ∘ operator as follows : assuming that f : E → E and g : E → E are permutations, h = f ∘ g is also a permutation from E to E.

## The algorithm

There are two algorithms: one for encryption and one for decryption. However, they are symmetrical in every way, and use the exact same mechanisms. If the first uses a permutation f during its first step, the latter will use the opposite permutation f<sup>-1</sup> during its last step.

### Password

The encryption and decryption algorithms use the same password **p<sub>0</sub>**, made out of **n = 256** different integers between 0 and n-1. Therefore each value is represented only once, giving us n! = 8.58 e<sup>506</sup> possible passwords. The proper algorithm is applied to the whole file **t** times sequentially, each time using a modified version of the password.

Each modified password **p<sub>i+1</sub>** is generated by adding to each of its values the (i mod n)<sup>th</sup> value from p<sub>i</sub>, and then computing their modulus n. When encrypting, the sequence of passwords used at each step will be p<sub>0 .. t-1</sub>. When decrypting, that sequence will be p<sub>t-1 .. 0</sub>.

### Permutations

The permutations that the algorithm uses are defined for the set of integers [0, n-1]. Each permutation is represented by an array of n integers, where the value contained at index i of the array is the image of the value i. This representation allows for efficient computing of the permutation function.  
**P** is a permutation that uses the passsword itself as its representation (both the passwords and the permutations are represented the exact same way)  (used to be pairs of first and last value, second and second-to-last...)
**C** is a permutation that maps each value x to the value (x + v) mod n  
**Q** is the composite permutation defined by P ∘ Cn ∘ P 


### Rotors

Il me reste un dernier objet à présenter avant de pouvoir crypter : le rotor. Un rotor est constitué de trois nombres, sa "valeur" étant la somme des trois. Il possède également un maximum, que ni les trois nombres ni la valeur ne peuvent égaler ou dépasser.
Les rotors supportent une seule opération : l'incrémentation. Elle est construite ainsi : tout d'abord, on ajoute un au premier nombre (et à la valeur). S'il atteint le maximum, on le remet à zéro et on ajoute un au second nombre. Si celui-ci atteint également le maximum, on procède de même sur le troisième nombre. Quand ce dernier est maximum, il est simplement remis à zéro.
Deux rotors sont utilisés par le mécanisme d'encodage : un rotor à types, qui a pour maximum huit, et un rotor à valeurs, avec pour maximum 32. Le rotor à types est initialisé en fonction de l'écart entre les nombres 0 et 31, 1 et 30 et 2 et 29 dans le mot de passe ; le rotor a valeurs commence sa vie à (0, 0, 0).

## Encodage

Chaque passe d'encodage commence par le calcul des Qn et l'initialisation des rotors pour le nouveau mot de passe. Ensuite, l'encodage se fait séquentiellement, en commençant au début du fichier et en allant vers la fin.
Pour chaque octet x, on procède ainsi :
1) On pose r = x modulo 32, t = x / 32 (division entière) ;
2) On demande au rotor à valeurs sa valeur v, et on prend n, le v-ième nombre dans le mot de passe ;
3) On pose s = Qn(r) ;
4) On ajoute 32 × (rotor à type + t) à r ;
5) On vérifie que r est toujours plus petit que 256 ;
6) On incrémente les deux rotors.

## Développements futurs
### Décryptage
Ça serait pas mal de vérifier que l'algorithme fonctionne en décryptant. :-)

### Exécution parallèle

L'exécution en parallèle du traitement permettrait de multiplier les performances par le nombre de cœurs, ce qui n'est pas négligeable sur les ordinateurs actuels. La programmation parallèle pourrait également conduire à la possibilité d'utiliser OpenCL pour exécution sur la carte graphique - si toutefois c'est possible.

Je propose pour ce faire de découper le fichier en blocs logiques de quelques dizaines d'octets (la taille exacte devrait être déterminée par essais et erreurs). Chaque bloc ne pourrait être utilisé que par un thread à la fois (utilisation de mutexes).

La fonction principale déclencherait l'exécution des threads les uns après les autres (avec un nombre maximum configurable), chacun étant responsable d'une passe (et donc initialisé avec le mot de passe correct). Ils se livreraient une course effrénée vers la fin du fichier (sans pouvoir se dépasser afin de préserver l'ordre des passes).

Une fois qu'un thread aurait terminé de travailler, il le ferait savoir à la fonction principale (comment ?) qui lui attribuerait une nouvelle passe et le relancerait, réutilisant les threads pour éviter d'appeler trop souvent les fonctions système qui les créent (elles sont peut-être lentes).

### Génération du mot de passe
Le mot de passe dans son état actuel est complètement nul. Retenir dans l'ordre une suite de 32 nombres n'est pas du tout simple, et résulterait en des mots de passe peu nombreux comme 0 1 2 3..., ce qui est dangereux pour l'utilisateur. Voici un essai pour trouver un algorithme qui transforme toute chaîne de caractères suffisamment longue en mot de passe viable. Il travaille sur des caractères Unicode afin de permettre à tous d'utiliser un texte dans leur langue.
1) Déterminer tous les caractères utilisés ;
2) Vérifier si l'on a au moins 32 caractères différents. Si c'est le cas, passer à l'étape 5 ;
3) Remplacer le premier caractère répété par un autre, plus grand que le plus grand actuellement utilisé ;
4) Revenir à l'étape 1 ;
5) Supprimer les deuxième, troisième, ... occurrences de chaque caractère ;
6) Tronquer la chaîne pour n'avoir plus que 32 caractères ;
7) Remplacer le caractère ayant la plus petite valeur Unicode par 0, le suivant par 1, etc dans l'ordre du standard.

